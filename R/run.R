#' mcmc_nngp_run_nonstationary_socket
#'
#' @param mcmc_nngp_list a mcmc_nngp_list generated by mcmc_nngp_initialize_nonstationary
#' @param burn_in numeric, between 0 and 1, default to 0.5. burn-in to compute diagnostics
#' @param seed numeric, random seed
#' @param n_cores integer, number of cores as passed to parallel::makeCluster
#' @param thinning numeric, between 0 and 1. Thinning parameter
#' @param plot_diags logical. Outputs diagnostic plots ? Default to TRUE
#' @param plot_PSRF_fields logical, Outputs PSRF diagnostic plots ? Default to FALSE.
#' @param debug_outfile character. log output to an external file ? Default to NULL (no log). Otherwise path of the wanted log file.
#' @param num_threads_per_chain integer. Number of threads to use by states. TODO
#' @param lib.loc character, location of parallel package. Default to NULL (current library)
#'
#' @returns a list
#' @export
#' @examples
#' \dontrun{TODO} 
run_socket = function(mcmc_nngp_list,
                      burn_in = .5,
                      seed = 1,
                      # MCMC parameters
                      n_cores = NULL,
                      thinning = .1,
                      plot_diags = TRUE,
                      plot_PSRF_fields = FALSE,
                      debug_outfile = NULL,
                      num_threads_per_chain = 1,
                      lib.loc = NULL)
{
  t_start = Sys.time()
  ######################################
  # Default parameters following model #
  ######################################
  # number of cores
  n_cores = min(c(
    n_cores,
    length(mcmc_nngp_list$states),
    parallel::detectCores() - 1
  ))
  gc()
  #################
  # Sanity checks #
  #################
  # parallelization
  if (!is.numeric(n_cores))
    stop("n_cores must be a positive round number")
  if ((floor(n_cores) != n_cores) | n_cores < 1)
    stop("n_cores must be a positive round number")
  # iterations and thinning
  if (!is.numeric(thinning))
    stop("thinning is a proportion and must be between 0 and 1")
  if ((thinning < 0) |
      (thinning > 1))
    stop("thinning is a proportion and must be between 0 and 1")
  if (!is.null(lib.loc)) {
    library(parallel, lib.loc =  lib.loc)
  }
  cl = parallel::makeCluster(n_cores, outfile = debug_outfile)
  mcmc_nngp_list_ = mcmc_nngp_list[-match(c("records", "states"), names(mcmc_nngp_list))]
  parallel::clusterExport(
    cl = cl,
    varlist = c(
      "mcmc_nngp_list_",
      "mcmc_nngp_update_Gaussian",
      "seed",
      "lib.loc"
    ),
    envir = environment()
  )
  
  if (!is.null(lib.loc)) {
    parallel::clusterEvalQ(cl = cl, expr = library(GpGp, lib.loc =   lib.loc))
    parallel::clusterEvalQ(cl = cl, expr = library(GeoNonStat, lib.loc = lib.loc))
    parallel::clusterEvalQ(cl = cl, expr = library(expm, lib.loc =   lib.loc))
    parallel::clusterEvalQ(cl = cl, expr = library(Matrix, lib.loc =   lib.loc))
  }
  
  rm(mcmc_nngp_list_)
  gc()
  iter_start = mcmc_nngp_list$iterations$checkpoints[nrow(mcmc_nngp_list$iterations$checkpoints), 1]
  # mcmc_sampling
  samples =
    parallel::parLapply(
      cl = cl,
      X = seq(length(mcmc_nngp_list$states)),
      fun
      = function(i)
        mcmc_nngp_update_Gaussian(
          data = mcmc_nngp_list_$data,
          hierarchical_model = mcmc_nngp_list_$hierarchical_model,
          vecchia_approx = mcmc_nngp_list_$vecchia_approx,
          state = mcmc_nngp_list$states[[i]],
          n_iterations_update = 100,
          thinning = thinning,
          iter_start = iter_start,
          seed = seed + iter_start + i,
          num_threads = num_threads_per_chain,
          lib.loc = lib.loc
        )
    )
  parallel::stopCluster(cl = cl)
  gc()
  # saving mcmc samples directly in parent environment
  for (i in seq(length(samples)))
  {
    # update states
    mcmc_nngp_list$states[[i]] = samples[[i]]$state
    # update records
    for (j in names(samples[[1]]$params_records))
    {
      mcmc_nngp_list$records[[i]][[j]] = abind::abind(mcmc_nngp_list$records[[i]][[j]], samples[[i]]$params_records[[j]])
    }
    
  }
  # update iterations
  mcmc_nngp_list$iterations$checkpoints = rbind(
    mcmc_nngp_list$iterations$checkpoints,
    c(
      iter_start + 100,
      mcmc_nngp_list$iterations$checkpoints[nrow(mcmc_nngp_list$iterations$checkpoints), 2] + as.numeric(Sys.time() -
                                                                                                           t_start, unit = "mins")
    )
  )
  print(mcmc_nngp_list$iterations$checkpoints)
  mcmc_nngp_list$iterations$thinning = c(mcmc_nngp_list$iterations$thinning,
                                         iter_start + which(seq(100) * thinning == floor(seq(100) * thinning)))
  # plot diagnostics
  if (plot_diags)
    diagnostic_plots(mcmc_nngp_list,
                     plot_PSRF_fields = plot_PSRF_fields,
                     burn_in = burn_in)
  # print(ESS)
  print("ESS")
  print(ESS(mcmc_nngp_list, burn_in = burn_in))
  return(mcmc_nngp_list)
}


#' mcmc_nngp_run_nonstationary_nonpar
#'
#' @param mcmc_nngp_list a mcmc_nngp_list generated by mcmc_nngp_initialize_nonstationary
#' @param burn_in numeric, between 0 and 1, default to 0.5. burn-in to compute diagnostics
#' @param seed numeric, random seed
#' @param thinning numeric, between 0 and 1. Thinning parameter
#' @param plot_diags logical. Outputs diagnostic plots ? Default to TRUE
#' @param plot_PSRF_fields logical, Outputs PSRF diagnostic plots ? Default to FALSE.
#' @param debug_outfile character. log output to an external file ? Default to NULL (no log). Otherwise path of the wanted log file.
#' @param num_threads_per_chain integer. Number of threads to use by states. TODO
#' @param lib.loc character, location of parallel package. Default to NULL (current library)
#'
#' @returns a list
#' @export
#' @examples
#' \dontrun{TODO} 
mcmc_nngp_run_nonstationary_nonpar = function(mcmc_nngp_list,
                                              burn_in = .5,
                                              seed = 1,
                                              # MCMC parameters
                                              thinning = .1,
                                              plot_diags = T,
                                              plot_PSRF_fields = F,
                                              num_threads_per_chain = 1,
                                              debug_outfile = NULL,
                                              lib.loc = NULL)
{
  t_start = Sys.time()
  ######################################
  # Default parameters following model #
  ######################################
  #################
  # Sanity checks #
  #################
  # iterations and thinning
  if (!is.numeric(thinning))
    stop("thinning is a proportion and must be between 0 and 1")
  if ((thinning < 0) |
      (thinning > 1))
    stop("thinning is a proportion and must be between 0 and 1")
  mcmc_nngp_list_ = mcmc_nngp_list[-match(c("records", "states"), names(mcmc_nngp_list))]
  iter_start = mcmc_nngp_list$iterations$checkpoints[nrow(mcmc_nngp_list$iterations$checkpoints), 1]
  # mcmc_sampling
  samples =
    lapply(
      X = seq(length(mcmc_nngp_list$states)),
      FUN =
        function(i)
          mcmc_nngp_update_Gaussian(
            mcmc_nngp_list,
            # hierarchical_model = mcmc_nngp_list_$hierarchical_model,
            # vecchia_approx = mcmc_nngp_list_$vecchia_approx,
            # state = mcmc_nngp_list$states[[i]],
            n_iterations_update = 100,
            # thinning = thinning, #Â TODO : not used !
            # iter_start = iter_start,
            # seed = seed + iter_start + i,
            num_threads = num_threads_per_chain #,
            # lib.loc = lib.loc
          )
    )
  gc()
  # saving mcmc samples directly in parent environment
  for (i in seq(length(samples)))
  {
    # update states
    mcmc_nngp_list$states[[i]] = samples[[i]]$state
    # update records
    for (j in names(samples[[1]]$params_records))
    {
      mcmc_nngp_list$records[[i]][[j]] = abind::abind(mcmc_nngp_list$records[[i]][[j]], samples[[i]]$params_records[[j]])
    }
    
  }
  # update iterations
  mcmc_nngp_list$iterations$checkpoints = rbind(
    mcmc_nngp_list$iterations$checkpoints,
    c(
      iter_start + 100,
      mcmc_nngp_list$iterations$checkpoints[nrow(mcmc_nngp_list$iterations$checkpoints), 2] + as.numeric(Sys.time() -
                                                                                                           t_start, unit = "mins")
    )
  )
  print(mcmc_nngp_list$iterations$checkpoints)
  mcmc_nngp_list$iterations$thinning = c(mcmc_nngp_list$iterations$thinning,
                                         iter_start + which(seq(100) * thinning == floor(seq(100) * thinning)))
  # plot diagnostics
  if (plot_diags)
    diagnostic_plots(mcmc_nngp_list,
                     plot_PSRF_fields = plot_PSRF_fields,
                     burn_in = burn_in)
  # print(ESS)
  print("ESS")
  print(ESS(mcmc_nngp_list, burn_in = burn_in))
  return(mcmc_nngp_list)
}
